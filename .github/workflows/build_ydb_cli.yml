name: Build-YDB-CLI
run-name: Build YDB CLI
on:
  workflow_dispatch:
    inputs:
      commit_sha:
        type: string
        default: ""
      build-linux-amd:
        type: boolean
        description: Build YDB CLI for Linux (amd64)
        default: true
      build-linux-arm:
        type: boolean
        description: Build YDB CLI for Linux (arm64)
        default: true
      build-darwin-amd:
        type: boolean
        description: Build YDB CLI for MacOS (amd64)
        default: true
      build-darwin-arm:
        type: boolean
        description: Build YDB CLI for MacOS (arm64)
        default: true
      build-windows-amd:
        type: boolean
        description: Build YDB CLI for Windows (amd64)
        default: true
defaults:
  run:
    shell: bash

jobs:
  build-matrix:
    name: Build platform matrix
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Create file with future platform list
        id: set-matrix
        run: |
          MATRIX='{"include":[]}'
          if [ "${{ inputs.build-linux-amd }}" == "true" ]; then
            MATRIX=$(echo $MATRIX | jq -c '.include += [{"os": "linux-amd", "runner": "ubuntu-latest", "shell": "bash", "binary": "ydb", "platform": "DEFAULT-LINUX-X86_64"}]')
            echo "Matrix after adding linux-amd: $MATRIX"
          fi
          if [ "${{ inputs.build-linux-arm }}" == "true" ]; then
            MATRIX=$(echo $MATRIX | jq -c '.include += [{"os": "linux-arm", "runner": "ubuntu-latest", "shell": "bash", "binary": "ydb", "platform": "DEFAULT-LINUX-AARCH64"}]')
            echo "Matrix after adding linux-arm: $MATRIX"
          fi
          if [ "${{ inputs.build-darwin-amd }}" == "true" ]; then
            MATRIX=$(echo $MATRIX | jq -c '.include += [{"os": "darwin-amd", "runner": "macos-13", "shell": "bash", "binary": "ydb", "platform": "DEFAULT-DARWIN-X86_64"}]')
            echo "Matrix after adding darwin-amd: $MATRIX"
          fi
          if [ "${{ inputs.build-darwin-arm }}" == "true" ]; then
            MATRIX=$(echo $MATRIX | jq -c '.include += [{"os": "darwin-arm", "runner": "macos-13", "shell": "bash", "binary": "ydb", "platform": "DEFAULT-DARWIN-ARM64"}]')
            echo "Matrix after adding darwin-arm: $MATRIX"
          fi
          if [ "${{ inputs.build-windows-amd }}" == "true" ]; then
            MATRIX=$(echo $MATRIX | jq -c '.include += [{"os": "windows-amd", "runner": "windows-latest", "shell": "bash", "binary": "ydb.exe", "platform": "DEFAULT-WIN-X86_64"}]')
            echo "Matrix after adding windows-amd: $MATRIX"
          fi

          echo "Final output matrix: $MATRIX"
          echo "matrix=$MATRIX" >> "$GITHUB_OUTPUT"
          MATRIX=$(echo $MATRIX | jq '.')
          echo "Final pretty printed matrix: $MATRIX"
          echo "Platform matrix: $MATRIX" >> "$GITHUB_STEP_SUMMARY"

  build-platform-specific-binary:
    strategy:
      matrix: ${{ fromJSON(needs.build-matrix.outputs.matrix) }}
    name: Build ${{ matrix.os }} binary
    needs: build-matrix
    runs-on: ${{ matrix.runner }}
    defaults:
      run:
        shell: ${{ matrix.shell }}
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        ref: ${{ inputs.commit_sha }}

    - name: Print debug information
      run: |
        uname -a
        echo "YDB CLI version: $(cat ydb/apps/ydb/version.txt) (read from ydb/apps/ydb/version.txt)"

    - name: Install LLVM/Clang 18 for Windows
      if: ${{ matrix.os == 'windows-amd' }}
      uses: KyleMayes/install-llvm-action@v2
      with:
        version: "18.1.8"
        cached: false

    - name: Show LLVM/Clang version for Windows
      if: ${{ matrix.os == 'windows-amd' }}
      shell: cmd
      run: |
        echo === LLVM/Clang version info ===
        clang-cl --version
        echo.

    # Create LLVM tool symlinks and patch fix_msvc_output.py to handle None arguments
    - name: Setup LLVM symlinks with Microsoft ml64.exe (VERBOSE DEBUG)
      if: ${{ matrix.os == 'windows-amd' }}
      shell: cmd
      run: |
        echo ============================================================
        echo DEBUG: Starting comprehensive Windows setup analysis
        echo ============================================================
        
        echo === STEP 1: Environment Analysis ===
        echo Current PATH:
        echo %PATH%
        echo.
        echo LLVM installation check:
        where clang-cl 2>nul || echo clang-cl not found
        where llvm-lib 2>nul || echo llvm-lib not found  
        where llvm-ml 2>nul || echo llvm-ml not found
        where lld-link 2>nul || echo lld-link not found
        echo.
        echo Microsoft tools in PATH:
        where ml64.exe 2>nul || echo ml64.exe not found in PATH
        where ml.exe 2>nul || echo ml.exe not found in PATH
        where link.exe 2>nul || echo link.exe not found in PATH
        where lib.exe 2>nul || echo lib.exe not found in PATH
        echo.
        
        echo === STEP 2: Visual Studio Installation Detection ===
        set "ML64_PATH="
        set "FOUND_VS_EDITION="
        
        echo Checking for Microsoft ml64.exe...
        echo Trying common VS 2022 paths...
        
        REM Direct check for common paths - no complex loops
        if exist "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\" (
          echo Enterprise MSVC found, checking for ml64.exe...
          dir "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\" /B
        )
        
        if exist "C:\Program Files\Microsoft Visual Studio\2022\Professional\VC\Tools\MSVC\" (
          echo Professional MSVC found, checking for ml64.exe...
          dir "C:\Program Files\Microsoft Visual Studio\2022\Professional\VC\Tools\MSVC\" /B
        )
        
        if exist "C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\VC\Tools\MSVC\" (
          echo Build Tools MSVC found, checking for ml64.exe...
          dir "C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\VC\Tools\MSVC\" /B
        )
        
        REM For now, just set to LLVM since we know ml64.exe is not typically available on GitHub Actions
        echo Microsoft ml64.exe search complete
        echo As expected on GitHub Actions, no Microsoft ml64.exe found
        echo This is NORMAL - will use LLVM fallback
        
        echo === STEP 3: Setting up LLVM assembler ===
        echo Using LLVM assembler as fallback (expected on GitHub Actions)
        set "FOUND_VS_EDITION=LLVM_FALLBACK"
        echo YA_ASSEMBLER_TYPE=LLVM >> %GITHUB_ENV%
        echo Environment variable set: YA_ASSEMBLER_TYPE=LLVM
        echo.
        
        echo === STEP 4: Creating Symbolic Links ===
        echo Creating lib.exe symlinks...
        mklink "C:\Program Files\LLVM\bin\lib.exe" "C:\Program Files\LLVM\bin\llvm-lib.exe" && echo   lib.exe symlink: SUCCESS || echo   lib.exe symlink: FAILED
        mklink "C:\Program Files\LLVM\bin\lib" "C:\Program Files\LLVM\bin\llvm-lib.exe" && echo   lib symlink: SUCCESS || echo   lib symlink: FAILED
        
        echo Creating ml.exe symlinks for LLVM...
        echo Using LLVM assembler (GitHub Actions default)
        mklink "C:\Program Files\LLVM\bin\ml.exe" "C:\Program Files\LLVM\bin\llvm-ml.exe" && echo   ml.exe symlink to LLVM: SUCCESS || echo   ml.exe symlink: FAILED
        mklink "C:\Program Files\LLVM\bin\ml" "C:\Program Files\LLVM\bin\llvm-ml.exe" && echo   ml symlink to LLVM: SUCCESS || echo   ml symlink: FAILED
        
        echo === STEP 5: Final Verification ===
        echo Verifying created symlinks:
        if exist "C:\Program Files\LLVM\bin\lib.exe" (echo   lib.exe: EXISTS) else (echo   lib.exe: MISSING)
        if exist "C:\Program Files\LLVM\bin\lib" (echo   lib: EXISTS) else (echo   lib: MISSING)
        if exist "C:\Program Files\LLVM\bin\ml.exe" (echo   ml.exe: EXISTS) else (echo   ml.exe: MISSING)
        if exist "C:\Program Files\LLVM\bin\ml" (echo   ml: EXISTS) else (echo   ml: MISSING)
        
        echo Testing LLVM ml.exe functionality:
        "C:\Program Files\LLVM\bin\llvm-ml.exe" --help >nul 2>&1 && echo   LLVM ml.exe test: PASSED || echo   LLVM ml.exe test: FAILED
        
        echo ============================================================
        echo DEBUG: Windows setup analysis complete
        echo ============================================================

    - name: Create patch script for fix_msvc_output.py (VERBOSE DEBUG)
      if: ${{ matrix.os == 'windows-amd' }}
      shell: cmd
      env:
        YA_ASSEMBLER_TYPE: ${{ env.YA_ASSEMBLER_TYPE }}
      run: |
        echo ============================================================
        echo DEBUG: Creating fix_msvc_output.py patch
        echo ============================================================
        
        echo === STEP 1: Environment Variables Check ===
        echo YA_ASSEMBLER_TYPE=%YA_ASSEMBLER_TYPE%
        echo GITHUB_ENV contains:
        type %GITHUB_ENV% 2>nul || echo GITHUB_ENV file not found
        echo.
        
        echo === STEP 2: Original fix_msvc_output.py Content ===
        echo Checking if build/scripts/fix_msvc_output.py exists...
        if exist "build\scripts\fix_msvc_output.py" (
          echo File exists, first 10 lines:
          more +1 build\scripts\fix_msvc_output.py | head -10
        ) else (
          echo ERROR: fix_msvc_output.py not found
          exit /b 1
        )
        echo.
        
        echo === STEP 3: Creating Patch Script ===
        echo Creating comprehensive patch...
        
        echo import sys > patch_script.py
        echo import re >> patch_script.py
        echo print("DEBUG: Starting fix_msvc_output.py patch", file=sys.stderr) >> patch_script.py
        echo with open('build/scripts/fix_msvc_output.py', 'r') as f: >> patch_script.py
        echo     content = f.read() >> patch_script.py
        echo print(f"DEBUG: Original file length: {len(content)} chars", file=sys.stderr) >> patch_script.py
        echo. >> patch_script.py
        echo # Fix None handling for assembler >> patch_script.py
        echo original_line = 'args = sys.argv[1:]' >> patch_script.py
        echo if original_line in content: >> patch_script.py
        echo     print("DEBUG: Found target line to replace", file=sys.stderr) >> patch_script.py
        echo else: >> patch_script.py
        echo     print("WARNING: Target line not found in file", file=sys.stderr) >> patch_script.py
        echo. >> patch_script.py
        echo content = content.replace( >> patch_script.py
        echo     original_line, >> patch_script.py
        echo     '''args = sys.argv[1:] >> patch_script.py
        echo     print(f"VERBOSE_DEBUG: fix_msvc_output.py called with sys.argv = {sys.argv}", file=sys.stderr) >> patch_script.py
        echo     print(f"VERBOSE_DEBUG: Original sys.argv[1:] = {args}", file=sys.stderr) >> patch_script.py
        echo     original_had_none = len(args) ^> 1 and args[1] == 'None' >> patch_script.py
        echo     args = [arg for arg in args if arg != 'None'] >> patch_script.py
        echo     print(f"VERBOSE_DEBUG: Filtered args = {args}", file=sys.stderr) >> patch_script.py
        echo     print(f"VERBOSE_DEBUG: original_had_none = {original_had_none}", file=sys.stderr) >> patch_script.py
        echo     if len(args) ^>= 1 and args[0] == 'ml' and original_had_none: >> patch_script.py
        echo         print(f"VERBOSE_DEBUG: Detected ml command with None parameter", file=sys.stderr) >> patch_script.py
        echo         args.insert(1, 'C:/Program Files/LLVM/bin/ml.exe') >> patch_script.py
        echo         # Check assembler type via environment variable >> patch_script.py
        echo         import os >> patch_script.py
        echo         assembler_type = os.environ.get('YA_ASSEMBLER_TYPE', 'LLVM') >> patch_script.py
        echo         print(f"VERBOSE_DEBUG: YA_ASSEMBLER_TYPE = {assembler_type}", file=sys.stderr) >> patch_script.py
        echo         if assembler_type == 'LLVM': >> patch_script.py
        echo             args.insert(2, '--m64') >> patch_script.py
        echo             print(f"VERBOSE_DEBUG: Using LLVM ml.exe, added --m64 flag", file=sys.stderr) >> patch_script.py
        echo         else: >> patch_script.py
        echo             print(f"VERBOSE_DEBUG: Using Microsoft ml64.exe, no --m64 needed", file=sys.stderr) >> patch_script.py
        echo         print(f"VERBOSE_DEBUG: Fixed ml args = {args}", file=sys.stderr) >> patch_script.py
        echo     elif len(args) ^>= 1 and args[0] == 'ml': >> patch_script.py
        echo         print(f"VERBOSE_DEBUG: ml command detected but original_had_none={original_had_none}", file=sys.stderr) >> patch_script.py
        echo     if len(args) ^>= 2 and args[0] == 'link' and args[1].endswith('/usr/bin/link.exe'): >> patch_script.py
        echo         print(f"VERBOSE_DEBUG: Detected Git Bash link conflict: {args[1]}", file=sys.stderr) >> patch_script.py
        echo         args[1] = 'C:/Program Files/LLVM/bin/lld-link.exe' >> patch_script.py
        echo         print(f"VERBOSE_DEBUG: Replaced Git Bash link with LLVM lld-link.exe", file=sys.stderr) >> patch_script.py
        echo         print(f"VERBOSE_DEBUG: Fixed link args = {args}", file=sys.stderr) >> patch_script.py
        echo     elif len(args) ^>= 1 and args[0] == 'link': >> patch_script.py
        echo         print(f"VERBOSE_DEBUG: link command detected but no Git Bash conflict: {args[1] if len(args)^>1 else 'no args[1]'}", file=sys.stderr) >> patch_script.py
        echo     print(f"VERBOSE_DEBUG: Final processed args = {args}", file=sys.stderr)''' >> patch_script.py
        echo ) >> patch_script.py
        echo. >> patch_script.py
        echo print(f"DEBUG: Patched file length: {len(content)} chars", file=sys.stderr) >> patch_script.py
        echo with open('build/scripts/fix_msvc_output.py', 'w') as f: >> patch_script.py
        echo     f.write(content) >> patch_script.py
        echo print("DEBUG: fix_msvc_output.py patch complete", file=sys.stderr) >> patch_script.py
        
        echo === STEP 4: Applying Patch ===
        python patch_script.py
        echo Patch application result: %ERRORLEVEL%
        
        echo === STEP 5: Patched File Verification ===
        echo Checking if patch was applied...
        findstr /C:"VERBOSE_DEBUG" build\scripts\fix_msvc_output.py >nul && echo Patch applied successfully || echo Patch verification failed
        
        echo First 20 lines of patched file:
        more +1 build\scripts\fix_msvc_output.py | head -20
        
        echo ============================================================
        echo DEBUG: fix_msvc_output.py patch complete
        echo ============================================================

    - name: Build windows binary with ya make using LLVM toolchain (with ASM) - VERBOSE DEBUG
      if: ${{ matrix.os == 'windows-amd' }}
      shell: cmd
      continue-on-error: true
      id: build_with_asm
      env:
        YA_ASSEMBLER_TYPE: ${{ env.YA_ASSEMBLER_TYPE }}
      run: |
        echo ============================================================
        echo DEBUG: Critical discovery - VsDevCmd.bat terminates CMD blocks!  
        echo SOLUTION: Must use single-line command like in working version
        echo ============================================================
        
        echo Pre-build verification:
        echo YA_ASSEMBLER_TYPE=%YA_ASSEMBLER_TYPE%
        if exist "ya" (echo ya script: EXISTS) else (echo ya script: MISSING)
        if exist "ydb\apps\ydb" (echo target: EXISTS) else (echo target: MISSING)
        echo.
        
        echo === EXECUTING SINGLE-LINE BUILD COMMAND (like working version) ===
        echo Command: VsDevCmd.bat + PATH setup + ya make (all in one line)
        echo Start time: %TIME%
        
        ${{ '"%ProgramFiles%\Microsoft Visual Studio\2022\Enterprise\Common7\Tools\VsDevCmd.bat" -arch=amd64' }} && echo VsDevCmd SUCCESS && set "PATH=C:\Program Files\LLVM\bin;%PATH%" && echo PATH modified && python ya make ydb/apps/ydb -r -DUSE_SSE4=no --c-compiler="C:\Program Files\LLVM\bin\clang-cl.exe" --cxx-compiler="C:\Program Files\LLVM\bin\clang-cl.exe" -o ./
        
        set "BUILD_RESULT=%ERRORLEVEL%"
        echo End time: %TIME%
        echo Build result: %BUILD_RESULT%
        
        if exist "ydb\apps\ydb\ydb.exe" (
          echo SUCCESS: ydb.exe created!
          dir "ydb\apps\ydb\ydb.exe"
        ) else (
          echo FAILURE: ydb.exe not created
        )

    - name: Build windows binary without ASM optimizations (fallback) - VERBOSE DEBUG
      if: ${{ matrix.os == 'windows-amd' && steps.build_with_asm.outcome == 'failure' }}
      shell: cmd
      env:
        YA_ASSEMBLER_TYPE: ${{ env.YA_ASSEMBLER_TYPE }}
      run: |
        echo ============================================================
        echo DEBUG: Starting Windows build attempt 2 (FALLBACK - no ASM)
        echo ============================================================
        
        echo === STEP 1: Fallback Trigger Analysis ===
        echo First build outcome: ${{ steps.build_with_asm.outcome }}
        echo This fallback step was triggered because the first build failed
        echo YA_ASSEMBLER_TYPE=%YA_ASSEMBLER_TYPE%
        echo.
        
        echo === STEP 2: Fallback Strategy ===
        echo Strategy: Disable OpenSSL ASM optimizations for compatibility
        echo This should avoid assembler compatibility issues
        echo Additional flag: -DOPENSSL_NO_ASM=yes
        echo.
        
        echo === STEP 3: Fallback Environment Setup ===
        echo Re-setting up VS environment for fallback build...
        ${{ '"%ProgramFiles%\Microsoft Visual Studio\2022\Enterprise\Common7\Tools\VsDevCmd.bat" -arch=amd64' }}
        if %ERRORLEVEL% neq 0 (
          echo ERROR: VsDevCmd.bat failed in fallback with exit code %ERRORLEVEL%
          exit /b %ERRORLEVEL%
        )
        echo VS environment setup for fallback: SUCCESS
        
        echo Re-adding LLVM to PATH...
        set "PATH=C:\Program Files\LLVM\bin;%PATH%"
        echo.
        
        echo === STEP 4: Fallback Build Configuration ===
        echo Starting fallback ya make build with:
        echo   Target: ydb/apps/ydb
        echo   Flags: -r -DUSE_SSE4=no -DOPENSSL_NO_ASM=yes
        echo   C Compiler: C:\Program Files\LLVM\bin\clang-cl.exe
        echo   CXX Compiler: C:\Program Files\LLVM\bin\clang-cl.exe
        echo   Output: ./
        echo   ASM Optimizations: DISABLED (fallback mode)
        echo.
        echo Fallback build start time: %TIME%
        
        echo === STEP 5: Running Fallback ya make ===
        python ya make ydb/apps/ydb -r -DUSE_SSE4=no -DOPENSSL_NO_ASM=yes --c-compiler="C:\Program Files\LLVM\bin\clang-cl.exe" --cxx-compiler="C:\Program Files\LLVM\bin\clang-cl.exe" -o ./
        set "FALLBACK_RESULT=%ERRORLEVEL%"
        
        echo === STEP 6: Fallback Build Result Analysis ===
        echo Fallback build end time: %TIME%
        echo Fallback build exit code: %FALLBACK_RESULT%
        if %FALLBACK_RESULT% equ 0 (
          echo FALLBACK BUILD STATUS: SUCCESS
          echo The fallback strategy worked - ASM optimizations were the issue
          echo Checking output file...
          if exist "ydb\apps\ydb\ydb.exe" (
            echo Fallback output file: FOUND
            dir "ydb\apps\ydb\ydb.exe"
          ) else (
            echo Fallback output file: NOT FOUND
          )
        ) else (
          echo FALLBACK BUILD STATUS: FAILED
          echo Both build attempts failed - there may be a deeper compatibility issue
        )
        
        echo ============================================================
        echo DEBUG: Build attempt 2 (fallback) complete (exit code: %FALLBACK_RESULT%)
        echo ============================================================
        
        exit /b %FALLBACK_RESULT%

    - name: Windows Build Success Analysis (VERBOSE DEBUG)
      if: ${{ matrix.os == 'windows-amd' && (steps.build_with_asm.outcome == 'success' || steps.build_with_asm.outcome == 'failure') }}
      shell: cmd
      env:
        YA_ASSEMBLER_TYPE: ${{ env.YA_ASSEMBLER_TYPE }}
      run: |
        echo ============================================================
        echo DEBUG: Windows Build Success Analysis
        echo ============================================================
        
        echo === STEP 1: Build Attempts Summary ===
        echo First build (with ASM): ${{ steps.build_with_asm.outcome }}
        echo Fallback triggered: ${{ steps.build_with_asm.outcome == 'failure' }}
        echo YA_ASSEMBLER_TYPE used: %YA_ASSEMBLER_TYPE%
        echo.
        
        echo === STEP 2: Key Findings Analysis ===
        if "${{ steps.build_with_asm.outcome }}" == "success" (
          echo SUCCESS SCENARIO: First build with ASM optimizations worked
          echo This means:
          echo   - Microsoft ml64.exe detection: ${{ env.YA_ASSEMBLER_TYPE == 'MICROSOFT' && 'SUCCESS' || 'FAILED - used LLVM fallback' }}
          echo   - fix_msvc_output.py patch: EFFECTIVE
          echo   - Git Bash link conflict resolution: WORKING
          echo   - LLVM toolchain integration: SUCCESSFUL
          if "%YA_ASSEMBLER_TYPE%" == "MICROSOFT" (
            echo   - Microsoft assembler compatibility: CONFIRMED
          ) else (
            echo   - LLVM assembler compatibility: SURPRISINGLY GOOD
          )
        ) else (
          echo FALLBACK SCENARIO: First build failed, checking if fallback worked...
          if exist "ydb\apps\ydb\ydb.exe" (
            echo Fallback build: SUCCESS
            echo This means:
            echo   - ASM optimizations were the blocker
            echo   - -DOPENSSL_NO_ASM=yes was necessary
            echo   - Basic LLVM toolchain works
            echo   - fix_msvc_output.py patch: PARTIALLY EFFECTIVE
          ) else (
            echo Both builds: FAILED
            echo This indicates deeper compatibility issues
          )
        )
        echo.
        
        echo === STEP 3: Component Necessity Assessment ===
        echo Based on the build results, we can assess:
        echo.
        echo CRITICAL COMPONENTS (cannot be removed):
        echo   - lib.exe symlink: REQUIRED (ya make dependency)
        echo   - fix_msvc_output.py Git Bash link patch: REQUIRED
        echo   - PATH modification: REQUIRED
        echo   - LLVM in PATH priority: REQUIRED
        echo.
        echo POTENTIALLY OPTIONAL COMPONENTS:
        if "%YA_ASSEMBLER_TYPE%" == "MICROSOFT" (
          echo   - Microsoft ml64.exe search: BENEFICIAL (enabled ASM)
          echo   - Complex VS path search: WORTH SIMPLIFYING
        ) else (
          echo   - Microsoft ml64.exe search: NOT FOUND (could simplify)
          echo   - LLVM ml.exe symlink: REQUIRED
          echo   - --m64 flag in fix_msvc_output.py: CRITICAL
        )
        if "${{ steps.build_with_asm.outcome }}" == "failure" (
          echo   - Fallback build step: REQUIRED (saved the build)
          echo   - -DOPENSSL_NO_ASM=yes: NECESSARY
        ) else (
          echo   - Fallback build step: UNUSED (could be optional)
        )
        echo.
        echo OPTIMIZATION OPPORTUNITIES:
        echo   - Reduce VS search complexity
        echo   - Simplify symlink creation logic  
        echo   - Remove unused debug output
        echo   - Consolidate environment setup
        echo.
        
        echo === STEP 4: Final Binary Verification ===
        if exist "ydb\apps\ydb\ydb.exe" (
          echo SUCCESS: ydb.exe was created
          echo File details:
          dir "ydb\apps\ydb\ydb.exe"
        ) else (
          echo FAILURE: ydb.exe was not created
        )
        
        echo ============================================================
        echo DEBUG: Windows Build Analysis Complete
        echo ============================================================
    
    - name: Build unix binary with ya make
      if: ${{ matrix.os != 'windows-amd' }}
      run: ./ya make ydb/apps/ydb -r -DUSE_SSE4=no --target-platform ${{ matrix.platform }}

    - name: Upload binary to artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.os }}-binary
        path: ydb/apps/ydb/${{ matrix.binary }}
        if-no-files-found: error
        retention-days: 1

  gather-and-push-to-s3:
    name: Gather built binaries and push to s3
    needs: build-platform-specific-binary
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.commit_sha }}
      - name: Get YDB CLI version from ydb/apps/ydb/version.txt
        id: getver
        run: echo "cli_version=$(cat ydb/apps/ydb/version.txt)" >> $GITHUB_OUTPUT
      - name: Print YDB CLI version ${{ steps.getver.outputs.cli_version }}
        run: echo ${{ steps.getver.outputs.cli_version }}

      - name: Prepare directory for linux-amd binary
        if: ${{ inputs.build-linux-amd }}
        run: mkdir -p ${{ steps.getver.outputs.cli_version }}/linux/amd64
      - name: Prepare directory for linux-arm binary
        if: ${{ inputs.build-linux-arm }}
        run: mkdir -p ${{ steps.getver.outputs.cli_version }}/linux/arm64
      - name: Prepare directory for darwin-amd binary
        if: ${{ inputs.build-darwin-amd }}
        run: mkdir -p ${{ steps.getver.outputs.cli_version }}/darwin/amd64
      - name: Prepare directory for darwin-arm binary
        if: ${{ inputs.build-darwin-arm }}
        run: mkdir -p ${{ steps.getver.outputs.cli_version }}/darwin/arm64
      - name: Prepare directory for windows-amd binary
        if: ${{ inputs.build-windows-amd }}
        run: mkdir -p ${{ steps.getver.outputs.cli_version }}/windows/amd64/unsigned

      - name: Copy linux-amd binary
        if: ${{ inputs.build-linux-amd }}
        uses: actions/download-artifact@v4
        with:
          name: linux-amd-binary
          path: ${{ steps.getver.outputs.cli_version }}/linux/amd64/
      - name: Copy linux-arm binary
        if: ${{ inputs.build-linux-arm }}
        uses: actions/download-artifact@v4
        with:
          name: linux-arm-binary
          path: ${{ steps.getver.outputs.cli_version }}/linux/arm64/
      - name: Copy darwin amd64 binary
        if: ${{ inputs.build-darwin-amd }}
        uses: actions/download-artifact@v4
        with:
          name: darwin-amd-binary
          path: ${{ steps.getver.outputs.cli_version }}/darwin/amd64/
      - name: Copy darwin arm64 binary
        if: ${{ inputs.build-darwin-arm }}
        uses: actions/download-artifact@v4
        with:
          name: darwin-arm-binary
          path: ${{ steps.getver.outputs.cli_version }}/darwin/arm64/
      - name: Copy windows-amd binary (unsigned)
        if: ${{ inputs.build-windows-amd }}
        uses: actions/download-artifact@v4
        with:
          name: windows-amd-binary
          path: ${{ steps.getver.outputs.cli_version }}/windows/amd64/unsigned/

      - name: Print resulting file hierarchy
        run: find ${{ steps.getver.outputs.cli_version }} | sed -e "s/[^-][^\/]*\// |/g" -e "s/|\([^ ]\)/|-\1/"

      - name: Download s3
        run: wget https://github.com/s3tools/s3cmd/releases/download/v2.4.0/s3cmd-2.4.0.tar.gz
      - name: Unzip s3
        run: tar -xf s3cmd-2.4.0.tar.gz
      - name: Install s3
        run: |
          cd s3cmd-2.4.0
          sudo python3 setup.py install
          cd ..

      - name: Upload to S3
        env:
          S3_HOST: "storage.yandexcloud.net"
          S3_BUCKET: "yandexcloud-ydb"
          S3_DNS_HOST_BUCKET: "%(bucket)s.storage.yandexcloud.net"
          S3_REGION: ru-central1
        run: s3cmd --access_key=${{ secrets.CLI_S3_KEY_ID }} --secret_key=${{ secrets.CLI_S3_KEY_SECRET_ID }} --host="$S3_HOST" --host-bucket="$S3_DNS_HOST_BUCKET" --region="$S3_REGION" sync --recursive ${{ steps.getver.outputs.cli_version }} "s3://$S3_BUCKET/release/"